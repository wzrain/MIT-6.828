# Part A: Multiprocessor Support and Cooperative Multitasking
Extend JOS to run on a multiprocessor system. Add system calls for user environments to create new environments. Cooperative round-robin scheduling allows the kernel to switch from one environment to another when the current environment voluntarily relinquishes the CPU. Preemptive scheduling allows the kernel to retake control of the CPU from an environment.

## Multiprocessor Support
We support symmetric multiprocessing (SMP), in which all CPUs have equivalent access to system resources such as memory and I/O buses. During the boot process there is a bootstrap processor (BSP) for initializing the system and booting the os, and application processors (APs) are activated by the boostrap processor after the os is running. The hardware and BIOS determine which processor is the bootstrap processor. \
In an SMP system each CPU has a local APIC (LAPIC) unit, which is for delivering interrupts throughout the system. The LAPIC will provide its CPU with an id. \
A processor accesses its LAPIC by memory-mapped I/O where some physical memory is hardwired to registers of I/O devices, so load/store instructions can be used to access device registers. The LAPIC lives in physical address `0xfe000000`, which is too high to be mapped at `KERNBASE`. Instead we map it at `MMIOBASE` (`0xef800000` in virtual address space).

### Exercise 1
We need to return the starting point of this block of memory, which is the old `base`. `size` should be rounded up and the ending point of the memory should not exceed `MMIOLIM`.

### Application Processor Bootstrap
Before booting APs, the BSP should collect information about the multiprocessor system, such as the number of CPUs, APIC ids, MMIO address of the LAPIC unit. This is done by retrieving the MP config table in BIOS's region of memory in `mp_init()` of `kern/mpconfig.c`. \
The AP bootstrap process is done by `boot_aps()` in `kern/init.c`. AP's entry code (`kern/mpentry.S`) is copied to a memory location that is addressable in real mode. Unlike the bootloader (?),  we can control where the AP will start executing. We copy the entry to `0x7000` (`MPENTRY_PADDR`), but any unused and page-aligned 640KB below would work. \
Then `boot_aps()` sends `STARTUP` interprocessor interrupt (IPI) to the LAPIC of a corresponding AP to activate it, along with an initial `CS:IP` address where the AP start executing (`MPENTRY_PADDR` here). Then after some setup the AP is put into protected mode with paging and then call `mp_main()` for the C setup. AP will signal `CPU_STARTED` flag in `cpu_status` of `struct CpuInfo` and `boot_aps()` will go to activate another one.
### Exercise 2
Just set the corresponding page of `MPENTRY_ADDR` as in use by setting `pp_ref = 1`. 
1. Compare `kern/mpentry.S` side by side with `boot/boot.S`. Bearing in mind that `kern/mpentry.S` is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro `MPBOOTPHYS`? Why is it necessary in `kern/mpentry.S` but not in `boot/boot.S`? In other words, what could go wrong if it were omitted in `kern/mpentry.S`? \
`kern/mpentry.S` has already entered protected mode to be executed above `KERNBASE`. So we need `MPBOOTPHYS` to turn the virtual address like `start32` back to physical address. (?)

### Per-CPU State and Initialization
It's important to dinstinguish between private CPU states and global states shared by the entire system. Private states are defined in `struct CpuInfo` of `kern/cpu.h`. `cpunum()` returns the id of the CPU that calls it, which could be an index of arrays like `cpus`. 
* **Per-CPU kernel stack.** Multiple CPUs can trap into the kernel at the same time, so separate kernel stacks for each processor are needed (represented by `percpu_kstacks`). CPU 0's stack still grows from `KSTACKTOP`, and CPU 1's stack grows from `KSTKGAP` bytes below the bottom of CPU 0's stack.
* **Per-CPU TSS and TSS descriptor.** We need separate TSSs to specify different kernel stacks' location (represented by `cpus[i].cpu_ts`). \
The fields of a TSS belong to two classes. A dynamic set that the processor updates in every task switching, such as registers and the selector of the TSS of the previous task. A static set that processors only read, such as the selector of the task's LDT. It's a continuous table (104 entries of 32 bits). \
TSS may reside anywhere in the linear space. When TSS spans a page boundary and the high addressed page is not present, an exception is raised. \
TSS is defined by a descriptor of two continuous 32 bits like other segments. The BASE, LIMIT, DPL fields are similar to other descriptors (except for gate descriptor where the selector it stores points to another entry in the table). The LIMIT should be no smaller than 103. The B-bit indicates whether the task is busy. 
* **Per-CPU current environment pointer.** `cpus[cpunum()].cpu_env` points to the currenty executing environment on the current CPU.
* **Per-CPU system registers.** All registers are private to a CPU.

### Exercise 3
Use `boot_map_region()` Note that `percpu_kstack[i]` is already the virtual address of the stack top of CPU i's kernel stack.
### Exercise 4
Initialize `thiscpu->cpu_ts` like how the global `ts` is initialized previously. The stack top and the gdt index are related to the CPU id. `sd_s` is for system segments. `ts_iomb` specifies the base address of the I/O permission bit map (so `sizeof(Taskstate)` means this map is directly after TSS). Note that the selector is not `GD_TSS0`. CPUs other than CPU 0 should have different indices (the high 13 bits of the selector) right after the index of `CPU 0`. So just add `cid << 3` to `GD_TSS0`.

### Locking
We need to address race conditions when CPUs run kernel code simultaneously. When an environment enters kernel mode it acquires the *big kernel lock* and releases when it returns to user mode. So only one environment can run in kernel mode at one time.
### Exercise 5
In `kern/init.c` `i386_init()` acquire the lock before `boot_aps()` to activate all APs. All APs will be waiting at `lock_kernel()` to get scheduled until `i386_init()` creates environments and makes one environment run by `sched_yield()`, which will call `env_run()` and release the lock. When we dealing with traps from user mode we also need to acquire the lock.

2. It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock. \
(?) Before the environment entering `trap()` to acquire the lock, the old `SS, esp` and so on have already been pushed into the kernel stack (this happens before the `ds, es` are pushed in `kern/trapentry.S`, which is before `trap()`). \
The reason why we have only one user stack (from `USTACKTOP`) is that each environment has its own page directory, so the same virtual address of the user stack is mapped to different physical address, so there is no interference among user environments. The kernel only has one kernel page directory.

## Round-Robin Scheduling
`sched_yield()` in `kern/sched.c` selects a new environment to run. It searches through `envs[]` circularly starting after the previously running environment, pick the first `ENV_RUNNABLE` and call `env_run()`. It must not run the same environment on two CPUs at the same time (can tell by `ENV_RUNNING`). `sys_yield()` is a system call to invoke `sched_yield()` for users to voluntarily give up the CPU.
### Exercise 6
Note that `curenv == NULL` means there are no previous running environments  or the whole process is over and we should quit. So we should find if there are environments with `ENV_RUNNABLE` in that situation. Add a new syscall `SYS_yield` in `kern/syscall.c` and invoke `sys_yield()`. Use `ENV_CREATE` to create `user_yield` environments in `kern/init.c`. \
Note that we need to use indices of `envs` array to traverse it rather than just use `env_link` which only leads to free environments. The index could be calculated with `ENVX` macro.

3. In your implementation of `env_run()` you should have called `lcr3()`. Before and after the call to `lcr3()`, your code makes references (at least it should) to the variable `e`, the argument to `env_run`. Upon loading the `%cr3` register, the addressing context used by the MMU is instantly changed. But a virtual address (namely `e`) has meaning relative to a given address context--the address context specifies the physical address to which the virtual address maps. Why can the pointer `e` be dereferenced both before and after the addressing switch? \
`e` should be in kernel space since `envs` is from `boot_alloc` and also be mapped at `UENVS` in `kern_pgdir`. The `env_pgdir` just copied these mapping from `kern_pgdir` in `env_setup_vm()`, so this should work in either context.
4. Whenever the kernel switches from one environment to another, it must ensure the old environment's registers are saved so they can be restored properly later. Why? Where does this happen? \
There is something to do with `Trapframe` (how the `Trapframe` can be popped as the stack top ?). The state is restored at `env_pop_tf()`. \
The process might be that in `env_pop_tf()` the assembly code takes an input of `tf`, and take this `tf` as the "stack" by set `esp` to 0. The `pop` instructions set corresponding registers, and `iret` makes the entry point, which is in `tf_eip`, as the starting point. When a trap happens, the `trapentry.S` will make the stack top looks the same as a `Trapframe`, and pass this `Trapframe` to the `trap()` function. In `trap()` if this trap is from a user environment this `Trapframe` will be copied to `curenv->env_tf`, which is the `Trapframe` of the current environment (since `curenv->env_tf` is not a pointer). Then let `tf` point to `curenv->env_tf` and just ignore things on the stack. So basically `Trapframe` is for saving the state for environments to continue executing from later. (The kernel stack should not be bothered since there is only one environment can enter the kernel mode at one time, and we don't need to empty it since every time we can get the kernel stack's original `esp` from TSS. (?))

## System Calls for Environment Creation
We need to allow not only *kernel* but also *user* environments to create and start other user environments. `fork()` system call copies the entire address space of the parent process to create a new child process. The only difference is the process id and the parent process id. In the parent `fork()` returns the child's id and in the child it returns 0. Each process gets its own address space and modifications are invisible to each other. \
There are more primitive syscalls for implementing `fork()`. `sys_exofork()` creates a new environment with an almost blank slate. Nothing is mapped in user address space and it's not runnable. It shares the register state as the parent when this is called. The parent returns the childs `envid_t`, and the child returns 0 (after it's made runnable by te parent). `sys_env_set_status` set the status of a specified environment to `ENV_RUNNABLE` or `ENV_NOT_RUNNABLE`. This is for marking a new environment ready to run. `sys_page_alloc` allocates a page of physical memory and maps it at a given virtual address. `sys_page_map` copies a page mapping from one environment's address space to another, which makes a memory sharing. `sys_page_unmap` unmaps a page at a given virtual address. \
The id 0 means the current environment, which is supported by `envid2env()`.

### Exercise 7
`sys_exofork()`. Use `env_alloc()` to create a new environment and set the status as `ENV_NOT_RUNNABLE`. Note that we need to copy all the `Trapframe` to the new environment to make the state completely the same. To make the return value different, the `eax` register need to be modified to 0 to indicate that this function returns 0 in the child process. The user interface of this function is not in `lib/syscall.c` but inlined in `inc/lib.h`, where it shows that the return value is stored in the `eax` register (`"=a" (ret)`). If this is not inlined, there will be an additional return procedure, which means that in the child values in the stack has also to be the same as in the parent, so that we can retrieve the correct return address (previous `eip`) using the `ebp` and `ebp + 4` with the `leave` instruction (`movl %ebp, %esp; popl %ebp`, basically remove the local variables from the stack and set `ebp` as what the current `ebp` points at and the stack top as the return address for `ret`). Even if the `ebp` and other registers are the same as in the parent, the value to which `ebp` points and the return address might be completely wrong. \
`sys_env_set_status()`. Use `envid2env()` to get the actual environment corresponding to the `envid`. The to-set `status` should be either `ENV_RUNNABLE` or `ENV_NOT_RUNNABLE`. \
`sys_page_alloc()`. Allocate a page with `page_alloc(1)` and try `page_insert()`. Check constraints for `va` and `perm`.\
`sys_page_map()`. To map an existing page to another address, we need `page_lookup()` first. This also helps find out the permission of this page and the new `perm` need to obey the read-write permission. Check constraints for addresses and `perm` as well.
`sys_page_unmap()` basically removes one mapping at `va`. The `page_remove()` function just decreases the reference counter of the mapped page. `page_free()` is called inside `page_remove()` if the reference counter reaches 0.

# Part B: Copy-on-Write Fork
In xv6 as well as the `dumbfork()` we used above, data from the parent's pages are all copied into new pages allocated for child. However, a call to `fork()` frequently is followed by `exec()` in the child process, which replaces the child's memory with a new program. So we wasted a lot of time in copying. \
Later versions of Unix use *copy-on-write* technique, which allow the parent and child to share the memory mapped into their respective address spaces until one of them modifies it. So `fork()` would copy mappings rather than the contents of pages, and mark shared pages read-only. When one of the processes tries to write, a page fault occurs, and the kernel makes a private writable copy of the page. This makes `fork()` cheaper. The child might only need to copy one page (the current page on the stack). 

## User-level page fault handling
It's common to set up an address space so that page faults indicate when some action needs to take place. Most Unix kernels only map one page on the stack and allocate additional pages "on demand". Page faults from different regions leads to different actions. Faults on the stack allocate and map new pages. Faults in the bss region allocate a new page filled with zeros. In systems with demand-pages executables, faults in the text region read the corresponding page off the disk. \
Instead of taking this traditional approach, we decide what to do about each page failt in user space. This design allows programs to define their memory regions (?).

### Setting the Page Fault Handler
A user environment will need to register a page fault handler entrypoint, via `sys_env_set_pgfault_upcall()`. The `Env` structure is added with `env_pgfault_upcall` to record this information.
### Exercise 8
Use `envid2env` to get the corresponding environment and check for errors. Register this syscall in `syscall()` with `SYS_env_set_pgfault_upcall`.

### Normal and Exception Stacks in User Environments
During normal execution a user environment runs on normal user stack starts from `USTACKTOP`. When a page fault occurs in user mode the kernel will restart the user environment running a designated user-level page fault handler on a different stack (user exception stack). We need to make the kernel automatically switch between stacks. \
The user exception stack is also one page size and starts from `UXSTACKTOP`. While running on the exception stack the user-level page fault handler can use syscalls to map new pages or adjust mappings. Then this handler returns via an assembly language stub to the faulting code on the original stack. \
Each user environment could use `sys_page_alloc()` to allocate its own exception stack.

### Invoking the User Page Fault Handler
The kernel will set up a trap frame of `struct UTrapframe` from `inc/trap.h` on the exception stack. It will push `esp, eflags, eip` and other registers and the error code and `fault_va`, which is the virtual address that caused the page fault (so we know which page should be copied or newly mapped since there's a page fault). The kernel arranges for the user environment to resume execution with the page fault handler running with this exception stack frame. \
If the user is already running on the user exception stack when an exception occurs, the page fault handler itself has faulted. We need to start a new stack frame under `tf->tf_esp` rather than `UXSTACKTOP`. Push a 32-bit empty work first and a `struct UTrapframe`.
### Exercise 9
We need to let the *user* handle this page fault, so we need to recover the execution of `curenv`, but let it execute the page fault handler. So we cannot just call the handler function in kernel mode. Instead, we pass the entry of the handler as `tf_eip` back to the user's `Trapframe` and set the `tf_esp` to the exception stack, which makes the user environment execute its page fault handler in user mode on the exception stack. Also we need to copy the `Trapframe` to the exception stack's `UTrapframe` for further recovery. \
We could check whether this is a nested exception by checking whether the `tf->tf_esp` is in the range of the exception stack.

### User-mode Page Fault Entrypoint
The assembly routine in `lib/pfentry.S` should call the C page fault handler (`_pgfault_handler`) and finishing the handler and return to the previous state in the `UTrapframe`. 
### Exercise 10
This is basically to implement a customized "`ret`" instruction. We need to recover register states and set the `esp` to correct location (either still on the exception stack in the nested exception situation, or on the normal stack), and resume the execution from `eip`. \
We cannot use `jmp` probebly because we need to have all the things done (such as recover the previous `esp`) before we change the `eip`. Since `eip` is on top of `esp`, we need to save the previous `eip` to a general register, which should be popped earlier and cannot be changed. We cannot use `ret` for the similar reason. The normal `ret` just pops `eip` from the stack top and start executing at that `eip` with the `esp` being the current value. The `iret` pops `eip` and `cs` and `eflags` to recover flags. If we also switch to different privilege it also pops `ss` and `esp` of the previous (different) stack (see `env_pop_tf()`). So if we just use `ret` here the `esp` will be incorrect. \
So if we want to return to previous states, we could setup the correct situation and then use `ret`, which means we need to put the `eip` on top of the previous stack, and execute the `ret` there. So after `ret` the execution starts from `eip` and the `esp` points to the previous stack. This is why we leave one empty slot on stack between nested exceptions. First we fill that empty slot (or the stack top of the user stack if it's ot nested) with the previous `eip`, with the help of general registers. Then do some pop, and set the `esp` to `esp - 4` to point to the new stack top (filled with the `eip`) to indicate where the `ret` instruction should pop from. Then `ret` and resume previous execution.

### Exercise 11
Since we are in user mode we need syscalls we implemented earlier to allocate pages and register the page fault handler. `_pgfault_upcall` is the entry defined in `lib/pfentry.S`, which leads to the customized `handler` we set here. This encapsulation inside the assembly code could provide the entire process of get in and out of the handler.

In `faultalloc`, we use `cprintf()` defined in `lib/printf.c`, which called `vcprintf()` and finally get into `vprintfmt()` which would get trapped for attempting to access to an invalid address. The handler will allocate a page at this address and store a string which looks like `"this string was..."`. So the fault is handled well. \
In `faultallocbad` however, we use `sys_cputs` which will check the user's memory validness first with `user_mem_assert` before calling `cprintf()`, which will give an assertion failure before faults occur.

## Implementing Copy-on-Write Fork
`fork()` in `lib/fork.c` creates a new environment and scan through the parent environment's address space and setup corresponding page mappings. It will copy a page only when one of the environments tries to write it. \
The parent installs `pgfault` with `set_pgfault_handler()`. Then `sys_exofork()` to create an environment. For each writable or copy-on-write page below `UTOP`, the parent calls `duppage`, which should map the page copy-on-write into the address of child and then *remap* the page copy-on-write in its own space (order ?). `duppage` sets both PTEs not writable and contain `PTE_COW` to distinguish it from read-only pages. The exception stack should be allocated in the child with a fresh page. Then The parent sets the page fault entry point for the child to look like its own. The child is now ready to run and the parent makes it runnable. \
When a page fault occurs the kernel invoke `_pgfault_upcall`, which leads to `pgfault()` handler. The handler checks whether the fault is a write (`FEC_WR` in the error code) and the PTE for the page is marked `PTE_COW`. Then a new page is allocated and mapped at a temporary location and the fault page is copied there. Then the new page is mapped to an appropriate address with rw permissions in place of the old read-only mapping. \
The page tables are mapped at `UVPT` to make PTE lookups easy.
### Exercise 12
In `fork()` we first set the page fault handler to `pgfault`, which will deal with the writing behavior to a copy-on-write page. Call `sys_exofork()` to create a child environment. Since the child's state is completely copied from the parent, after the child is runnable and selected to run, it will also start from this very place, only with a return value of 0 from `sys_exofork()`. So if the returned id `envid` is 0, we need to fix the `thisenv` which used to refer to the parent environment and copied to the child when the memory mapping is copied. \
This means we cannot use `thisenv` in `pgfault()`, since when there is a page fault about copy-on-write pages, `thisenv` may still point to the parent. This can happen exactly when we try to fix `thisenv` where we need to write a new address to `thisenv` which may cause a page fault. So we need to use `sys_getenvid()` to get the current environment id, which reads `curenv`'s id. `curenv` is set to the current environment at `env_run()` before this environment actually starts running. \
In the parent process we need to copy the existing mappings (`PTE_P` is set) to the child process with `duppage()`. We don't need to copy the kernel space as `dumbfork()` (?), so only `UTEXT` to `UTOP` would work. From `USTACKTOP` to `UXSTACKTOP` (`UTOP`) we need to allocate one new page for the exception stack for the page fault handling. \
In `fork()` and `duppage()` we need to check the permission of the current page. To read the page directory and the page table we need `uvpt` which is set in `lib/entry.S`. Since we mapped the kernel page directory at `PDX(UVPT)` of the kernel page directory itself, we could access to all the page tables as normal pages at `UVPT`. So all page table entries is accessible in the range of `[UVPT, UVPT + PTSIZE)`. Also, if want to access to the page directory, we just go to `UVPT + (UVPT >> PGSHIFT)`, because `PDX(UVPT + (UVPT >> PGSHIFT)) == PTX(UVPT + (UVPT >> PGSHIFT)) == PDX(UVPT)`, so we just go into that `PDX(UVPT)`th index twice and access to the page directory. This is set as `uvpd` in `lib/entry.S`. \
So in `duppage()` we just find out the permission of the corresponding page in `uvpt` and check whether it's writable or copy-on-write. First map the page to the same address in the child space, and then remap (change the permission) in the parent space (Ordering matters ?). Note that the `uvpt` is only readable, so we need syscalls even if we only change the permission (map to the same place in the same environment). Here it's ok to use `thisenv` since this is only happening in the parent. \
Then just use `sys_page_alloc` for the new exception stack, and set the `_pgfault_upcall` of `lib/pfentry.S` as the child's `env_pgfault_upcall` (the child's `_pgfault_handler` which is called in `_pgfault_upcall` might be also `pgfault()` which is set at the beginning of `fork()` and copied to the child (?)). Then just set the child to runnable. \
When a page fault about copy-on-write occurs (how does the page fault get invoked when we try to write a copy-on-write page ?), the `pgfault()` will eventually get invoked and allocate a new page at `PFTEMP` and copy the old memory there. Then unmap the faulting address and map it to the page at `PFTEMP`. Finally unmap the `PFTEMP`. As is mentioned above, the environment id must come from the system call. \
If we accidentally return 0 rather than the child's id, we get a lot of things like 000 rather than a binary-tree-like output from `user/forktree.c`. The reason is that if we return 0 at the end, both parent and child will execute inside `if (fork() == 0)`, which will eventually `exit()`. So now there are not two child environments from `forkchild()`, but only one child from `forkchild('0')` because the parent will `exit()` in there and not execute `forkchild('1')`. So the parent itself will start to fork another tree, the string of which also starts with `0`. So in the entire program there will be no `1`s involved since all process exits before it gets to `forkchild('1')`.

# Part C: Preemptive Multitasking and Inter-Process communication (IPC)
## Clock Interrupts and Preemption
We need to preempt a running environment to retake control of the CPU from bugs or malicious code which might get stuck in an infinite loop. So we should support external hardware interrupts from the clock hardware.

### Interrupt discipline
External interrupts are referred to as IRQs. There are 16 IRQs numbered 0 to 15. The clock interrupt is IRQ 0, the handler of which could be retrieved from `IDT[IRQ_OFFSET + 0] (IDT[32])`. `IRQ_OFFSET` is chosen so that device interrupts do not overlap with processor exceptions. \
In JOS we disable external interrupts when in the kernel. This is controlled by `FL_IF` bit of the `eflags` register. The external interrupts is enabled if this is set. We will handle it when we leave and enter user mode. \
In user environments when an interrupt arrives it gets passed through to the processor and handled by interrupt handlers. Otherwise if the flag bit is clear, interrupts are masked or ignored until interrupts are reenabled. The interrupts is actually masked with the very first instruction of the bootloader (`cli`).
### Exercise 13
Add trap handlers in the same way as in lab 3 with `TRAPHANDLER_NOEC`. Set the `FL_IF` bit of `tf_eflags` to enable interrupts.

### Handling Clock Interrupts
In `user/spin.c` the child spun in a loop and the kernel never got the control back. We need to program the hardware to generate clock interrupts periodically, which force control back to kernel and eventually switch to a different user environment. \
Calls to `lapic_init()` and `pic_init()` in `i386_init()` set up the clock and the interrupt controller.
### Exercise 14
Call `lapic_eoi()` to acknowledge interrupts and then yield to another environment if the `tf_trapno` is `IRQ_OFFSET + IRQ_TIMER`. \
Note that when we enter the kernel we need to disable the interrupts, which means we need to clear the `IF` flag bit. However if we set the `FL_IF` bit initially, and enter through a trap gate (e.g. when a page fault (`tf_trapno == 14`) occurs), the `IF` will still be set, so the interrupt will not be disabled. So we need to set the gates as interrupt gates to disable the interrupt when entering kernel mode, which means set the second argument of `SETGATE` as 0. \
In `user/spin.c` whenever the child is stuck in the loop, there will be an interrupt to resume another environment (the parent). The parent will call `sys_yield()` to switch to the child again. After some back and forth the child is destroyed in the parent.

## Inter-Process communication (IPC)
The operating system provides the illusion that each program has a machine all to itself. It also allows programs to communicate with each other when they want to. The pipe model is an example.

### IPC in JOS
Additional syscalls are to implement for IPC mechanism, `sys_ipc_recv` and `sys_ipc_try_send`. `ipc_recv` and `ipc_send` are two library wrappers. \
The messages are a single 32-bit value and optionally a single page mapping. Allowing page mapping passng provides a way to transfer more data and set up shared memory.

### Sending and Receiving Messages
`sys_ipc_recv` is for receiving messages. This syscall deschedules the current environment and does not run it again until a message has been received. Any other environments can send it a message when an environment is waiting for a message. The IPC system makes sure that an environment cannot cause another one to malfunction simply by sending messages. So the `envid2env()`'s `checkperm` does not need to be set, so there;s no restriction about parent-child relations in IPC. \
`sys_ipc_try_send` is for try sending values. It sets the receiver id and the value to be sent. If the target environment does not wait for a message it just return `-E_IPC_NOT_RECV`. \
The library function `ipc_recv` in user space will call `sys_ipc_recv` and then look up the information about received values in the current environment's `struct Env`. The `ipc_send` repeatedly calls `sys_ipc_try_send` until it succeeds.

### Transferring Pages
If an environment calls `sys_ipc_recv` with a valid `dstva` argument, the environment will wait for a page mapping. If a sender sends a page the page should be mapped at `dstva`. If there's already a mapping, the previous one is unmapped. \
If `sys_ipc_recv` is called with a valid `srcva`, the sender wants to send the page mapped at `srcva` to the receiver with certain permissions. Eventually the sender and receiver shares the same physical page. Both the sender and the receiver have to indicate for a page to be transferred. \
After any IPC the kernel sets the new field `env_ipc_perm` in `struct Env` of the receiver as the permissions of the received page, or zero if no page is received.

### Implementing IPC
### Exercise 15
`sys_ipc_recv()` uses `envid2env` to get the receiving environment. The `checknum` should be set as 0. If the receiving environment is not actually receiving (`env_ipc_recving` is false) just return `-E_IPC_NOT_RECV`, which will later let `ipc_send()` repeat. Do some normal checks if a page is to be shared (`srcva < UTOP`). Similar in `sys_page_map()`, we use `page_lookup()` to find the corresponding page table entry and do validation and permission checking. If the receiving environment `dstenv` is receiving that page (`env_ipc_dstva < UTOP`), try to insert the page with `perm`. Then set the corresponding fields in `dstenv`. Finally we need to set the `eax` register of `dstenv`'s trap frame to let it return properly later. When it's waiting for a value to receive, it just get descheduled in the kernel. So when it finishes receiving and is set to runnable by the receiver, it will be resumed with the same trap frame when it enters the `sys_ipc_recv()` and continue executing things after `sys_ipc_recv()`. So we need to set the return state properly. In `lib/syscall.c` the return value of syscalls is set in the `eax` register, which is what we need to set before the receiving environment is ready to run again. Here we just set `eax` to 0 as the return value. If we don't do anything, the syscall number (here it's 12 (`SYS_ipc_recv`)), which is the input of `eax`, will be returned, and cause panic inside `syscall()` of `lib/syscall.c`. \
`sys_ipc_recv()` checks whether the receiving address is page aligned if it wants a page (`dstva < UTOP`). Then it just set fields of `curenv` and deschedule it to wait for data. Later it will be set to runnable by the corresponding sender. \
`ipc_recv()`. If `pg` is null, just set it to `UTOP` to indicate that no page passing is needed. Then just call `sys_ipc_recv()` for receiving. If the receiving succeeds and storage is needed, just store the sender's id and the permission (both from the fields of the current environment (`thisenv`)). `thisenv` is set at the `lib/libmain.c` for every user environment. It is set in `fork()` when new environments is created. The return value is the received value. \
`ipc_send()` sets `pg` to `UTOP` if `pg` is null, same as the above one. It repeatedly try to send the messages until `sys_ipc_try_send()` returns 0. To make CPU nicely used, we could deschedule the sending process after every sending attempt with `sys_yield()` (it's ok to not use this ?).