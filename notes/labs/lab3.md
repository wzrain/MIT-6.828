# Part A: User Environments and Exception Handling
The kernel (`kern/env.c`) maintains three global variables. `struct Env *envs` points to an array representing all environments (processes). The max number of environments is `NENV`. `static struct Env *env_free_list` keeps all inactive `Env`s (for alloc and dealloc of environments). `struct Env *curenv` keeps track of the currently executing environment.

## Environment State
`inc/env.h` defines `struct Env`. `struct Trapframe env_tf` holds saved register values while the environment is not running (i.e. the kernel or a different environment is running). `struct Env *env_link` points to the next free `Env`, which is on the `env_free_list`. `envid_t env_id` is the unique id for the environment that currently *using* this `Env` slot (in the `envs` array). After this environment terminates there might be another environment with a different id reusing this very slot (freed and allocated for another environment again). `envid_t env_parent_id` stores the environment that creates this environment (family tree). `enum EnvType env_type` is used to distinguish special environments, most of which are `ENV_TYPE_USER`. `unsigned env_status` indicates the environment is inactive (`ENV_FREE`, on the `env_free_list`) or waiting to run (`ENV_RUNNABLE`) or running (`ENV_RUNNING`) or active but waiting for something before it could run (`ENV_NOT_RUNNABLE`) or zombie environment (`ENV_DYING`). `pde_t *env_pgdir` si the environment's page directory's virtual address.\
Only one kernel stack is needed because there can be only one environment active at one time in the kernel.

## Allocating the Environments Array
### Exercise 1
Basically the same pattern as in lab 2.

## Creating and Running Environments
Now we load a static binary image that is embedded within the kernel as an ELF executable image. Use `-b binary` option for the linker to let files linked as "raw" binary files rather than `.o` files. The linker generates some mangled symbol names for the kernel to reference the embedded binary files.

### Exercise 2
`env_init()` initializes every element of `envs` and put all of them into `env_free_list` in the same order.\
`env_setup_vm()` gives the environment's page directory (`e->env_pgdir`) a corresponding physical page. We could follow the mapping above `UTOP` from `kern_pgdir`. By *not need to make any more calls to `page_alloc`*, we could (and should) let `e->env_pgdir` store the same addresses as `kern_pgdir` above `UTOP`, because the page directory stores the physical address to page tables for the mapping of approx. 256MB kernel address. Every environment shares this kind of mapping above `UTOP` (Why do they need this mapping (?)), and this function is used whenever an environment is allocated (in `env_alloc()`). Reference counter needs maintaining because `env_free()` needs to find out whether the page corresponding to this page directory could be freed (`kern_pgdir` don't have this worry).\
`region_alloc()` allocate a certain length of memory from a certain virtual address for a certain environment by inserting new pages into `e->env_pgdir`. Perform alignment as well. Note that the memory space might need two pages to represent even if the memory length is smaller than one page, so actually we need to rounddown the starting point and roundup the end point separately. \
`load_icode()` loads all loadable segments from the ELF image into user's memory. Similar to the boot loader in `boot/main.c`, it goes through program headers. Note that we are loading segments to user's memory, which means we need `e->env_pgdir` as the page directory to be modified. So we need to reset `cr3` register. Different page directories indicate separate virtual address spaces. Then call `region_alloc()` to allocate memory for each segment. Just copy the actual data of `ph->p_filesz` to `ph->p_va`. This is the counterpart of `readsect` in `boot/main.c`. We need to make the entry of the ELF header the execution starting point, which could be done by modifying the `struct Trapframe env_tf` of the environment. The reason why `eip` register is the return address of function calling in lab 1 is that it actually stores the next instruction, so it makes sense to store `eip` on the stack as the return address. Here we can store the entry point to `tf_eip` of the `Trapframe` to specify the execution point.\
`env_create()` allocates an environment with `env_alloc()`,  which take the first free `envs` struct and setup virtual memory (`env_setup_vm()`) and specify environment attributes and `Trapframe` values, and load the binary image into that environment's memory with `load_icode()`. Only called during kernel initialization before user-mode envs running (what about later? env_alloc ?).\
`env_run()` performs context switch by changing the `curenv`'s status (what about its `Trapframe` ? Have something to do with the `env_pop_tf()` implementation) and let `curenv` points to the new environment. Switch to the new page directory and retrieve the new `Trapframe` by `env_pop_tf()`, which does not return. It leads to the entry point we specified earlier in `tf_eip`. In this case the entry point `0x800020` is specified in `lib/entry.S`, also shown in `obj/user/hello.asm`. We could execute all the way to `0x800a1c` to check whether we entered the user mode.

## Handling Interrupts and Exceptions
The instruction in `0x800a1c: int $0x30` system call is a dead end. Execption and system call handling is needed to let kernel recover control from user mode.

(From Section 6.3 of 80386 manual)\
Privilege levels are contained by descriptors (the DPL field) and selectors (bit 1-0, RPL) and an internal processor register (CPL). Normally the CPL is equal to the DPL of the segment that the processor is currently executing. There are four levels with 0 the highest privilege. Two-level systems just use level 0 and 3. \
For address operands the program must load the selector of a data segment into a data-segment register, and the privilege evaluation is performed when the selector is loaded into the data-segment register. Three privilege levels (CPL, DPL, RPL) are needed for checking. The DPL should be numerically larger than or equal to the maximum of CPL and the selector's RPL. That means a procedure can only access to the same or less privileged data. This could be used to prevent applications from reading and changing tables of the operating system. \
Control transfers are accomplished by instructions JMP, CALL, RET, INT, IRET and exception and interrupt mechanisms. In JMP, CALL, RET instructions, we could either transfer within the current code segment or refer to other segments, which needs privilege checking. There are two ways for referring to other segments. One is to select the descriptor of that segment, another is to select a call gate descriptor. Without using a call gate, we need the CPL and the DPL of the descriptor of the target segment. If the conforming bit of the target segment's descriptor is set, CPL might be greater than DPL. For nonconforming segments, control can be transffered without a gate only to segments at the same level of privilege.\
Gate descriptors are used for control transfers among segments at different privilege levels. A call gate may be in the GDT or an LDT, and is used to define an entry point of a procedure and specify privilege level of the entry. The operand's selector part selects a gate and the offset is not used. We need CPL, RPL of the selector corresponding to the call gate, the DPL of the gate descriptor and the DPL of the target segment's descriptor for privilege checking. 

Task gates, interrupt gates and trap gates might be in the IDT. IDT's location is stored in the IDT register (IDTR). If the processor indexes to an interrupt gate or trap gate, it invokes the handler in a similar manner to the call gate. The selector points to an executable segment descriptor in the GDT or the current LDT. \
The IRET instruction is used to exit from an interrupt procedure. The difference between a normal procedure is that the EFLAGS register is involved. Interrupts through interrupt/trap gates causes TF (the trap flag) to be reset after the previous EFLAGS is stored on the stack, preventing debugging activities from affecting the interrupt response. After IRET the TF bit is restored from the saved EFLAGS. An interrupt gate reset IF (the interrupt-enable flag), preventing other interrupts from interfering. 

(How does segments related to different pgdirs ?)

## Basics of Protected Control Transfer
Protected control transfers cause the processor to switch from user to kernel mode (CPL=0). An interrupt is asynchronous like I/O events whereas an exception is synchronously caused by the currently running code itself. *Protected* means the processor ensures the kernel can be entered under controlled conditions rather than let the running code decide.
1. **The Interrupt Descriptor Table.** The processor ensures that interrupts and exceptions can only lead to specific entry points determined by the kernel itself. The x86 allows up to 256 different entry points, each with a different interrupt vector, which is number between 0 and 255. The vector is determined by interrupt source and can be used as an index into the interrupt descriptor table (IDT), which is in kernel memory. Each entry has the value to load into `eip` which points to the kernel code designated to handle that exception and the value to load into `CS` register which includes the privilege level in bits 0-1 at which the handler is to run. All exceptions are handled in kernel mode of privilege level 0.
2. **The Task State Segment.** The processor needs to save the old state like original values of `eip` and `CS` before exception handler is invoked. The save area should also be protected. So the x86 also switches to a kernel stack. The task statement segment (TSS) specifies the segment selector and address (offset ?) where the stack is. The processor pushes old `SS (?), esp, EFLAGS, CS, eip` to the new stack. Then it loads `CS` and `eip` from IDT and set `esp` and `SS` to refer to the new stack. The `ESP0` and `SS0` fields of the TSS is for the kernel stack when entering the kernel mode (`SS0` for selector and `ESP0` for address ?).

## Types of Exceptions and Interrupts
Synchronous exceptions use interrupt vectors between 0 and 31, for example page faults causes vector 14. Vectors greater than 31 are for software interrupts (system calls ?) or async hardware interrupts.

## An Example
For division-by-zero exception, `SS0` and `ESP0` stores `GD_KD` and `KSTACKTOP` respectively. We push old values starting from address `KSTACKTOP` and go to IDT entry 0 (for divide errors) and set new `CS:EIP` according to the entry.\
For some exceptions (e.g. page faults) we also need to push an *error code* into the new stack.

## Nested Exceptions and Interrupts
If the processor is already in kernel mode when exception or interrupt happens, the CPU just push more old values on that same kernel stack, which gives nested exceptions. Since no stack switch is needed, there's no need to push old `SS` and `esp`. This is importatnt for protection implementation. We should make sure that the old state CAN be pushed into the kernel stack, which means no stack overflow or something.

## Setting Up the IDT
Each exception or interrupt should have its own handler in `kern/trapentry.S`. `trap_init()` should initialize the IDT with the handlers' addresses. Each handler should build a `struct Trapframe` on the stack and call `trap()` to handle the exception or dispatch to a specific handler function.

### Exercise 4
The `TRAPHANDLER(name, num)` macro is used to define a global function `name` to handle the trap `num`.  `TRAPHANDLER_NOEC` is for traps with no error code. So we just use these macros to generate entry points for every trap number defined in `inc/trap.h`. We could find out whether a trap has an error code by consulting Chapter 5 of the IA-32 manual. \
The fields of `struct Trapframe` (see `inc/trap.h`) are defined in the opposite order in which register values appear at the top of the stack when an exception/interrupt occurs (The order of pushing is `SS`, `esp`, `EFLAGS`, `CS`, `eip`, error code (if any)). These register values are pushed into the stack by the processor, whereas things from the trap number (`tf_trapno`) are sorted out manually. In `TRAPHANDLER(_NOEC)` the trap number has already been pushed into the stack. So in order to "make the stack look like a `struct Trapframe`", we still need to push `ds` and `es` and other registers (which could be pushed via `pushal`) into the stack in `_alltrap`. The reason why the order of fields in `struct Trapframe` is opposite is the stack grows from high address to low, whereas structs start from low address to high. So the last field should be in stack first and first field is the last in. \
Then we need to load `GD_KD` as the selector into `ds` and `es`. Note that we cannot directly load data into these segment registers, we need to use another register as an intermediate. Since the registers are 16-bit, we use `movw` for loading. The `esp` is currently pointing to the "starting" point (`tf_regs`) of a `struct Trapframe`, so it could be used as a pointer to `Trapframe` as an argument. \
In `trap_init()` we need to specify the declaration of handler functions (the definitions are in `trapentry.S` by `TRAPHANDLER(_NOEC)`). These functions are set to global so no need for `extern` declarations. We set corresponding IDT entries for every trap defined in `inc/trap.h` with the `SETGATE` macro defined in `inc/mmu.h`. Trap number 0-31 are exceptions, so `istrap` is 1 except for the trap number 48 (system calls). The selector in the gate descriptor should be the selector for the actual handler function, which should be `GD_KT` (kernel text). The offset is actually the function's address (maybe because the segmentation has no effect, as is told in lab 2 ?), so just pass the function pointer as the offset. The privilege is highest (DPL=0). (The segmentation mechanism here has no effect on addressing, but might be used for privilege control or something ?)
1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)\
Different handling methods. Some needs restoring like I/O interrupt while some indicate errors. We don't know the actual number of the trap in the handler, so it cannot be used as a parameter for one overall handling function (maybe feasible ? Still similar to separate to many specified handlers).
2. Did you have to do anything to make the `user/softint` program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but `softint`'s code says `int $14`. Why should this produce interrupt vector 13? What happens if the kernel actually allows `softint`'s `int $14` instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?\
Similar to a `CALL` instruction, we need to make sure `max(CPL, DPL) <= gate DPL` and `target segment EPL <= CPL`. So the DPL of the gate descriptor determines what privilege levels can use the gate. Entries in IDT now are all of DPL=0, which means only the highest level programs can use the gates. So if we want to execute `int $14` in user mode, there will be a general protection fault since the privilege rules are violated. 

# Part B: Page Faults, Breakpoints Exceptions, and System Calls
## Handling Page Faults
When the processor takes a page fault, it stores the linear (virtual) address that caused the fault in a processor control register `CR2`.
### Exercise 5
Check whether the trap number of the input `Trapframe` is 14 (`T_PGFLT`). Call `page_fault_handler` if yes.

## The Breakpoint Exception
The breakpoint exception, interrupt vector 3 (`T_BRKPT`), is used to let debuggers insert breakpoints by temporarily replace the instruction with `int3` software interrupt instruction. We want to use this exception to invoke the kernel monitor.

### Exercise 6
The `int3` instruction causes the breakpoint exception. It's not used for handlers. Here this exception invoking the kernel monitor means that the monitor is regarded as the handler. So when `tf_trapno` is `T_BRKPT`, we need to invoke `monitor()` in `kern/monitor.c`, which is the kernel monitor, as the handler. Note that `int3` might be invoked in user mode, so the DPL of the gate descriptor should be 3.

3. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to `SETGATE` from `trap_init`). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault? \
Similar situation in Question 2 about `int $14`. It's about the gate descriptor's DPL.
4. What do you think is the point of these mechanisms, particularly in light of what the `user/softint` test program does? \
Experiments about what the privilege checking does during exception/interrupt (`int` instruction) handling.

## System calls
User processes ask the kernel to do things by system calls. System calls enter the processor into kernel mode. The processor and the kernel cooperate to save user's state. \
Here we use `int` instruction, particularly `int $0x30` (`T_SYSCALL`). This cannot be generated by hardware, so there's no ambiguity caused by allowing user code to generate it.\
The application passes the sys call number and the sys call arguments in registers so that the kernel does not need to search in the user stack or the instruction stream. The syscall number goes in `%eax` and the arguments go to `%edx, %ecx, %ebx, %edi, %esi`. The return value is passed by the kernel to `%eax`.

### Exercise 7
We've already added the syscall handler in `kern/trapentry.S` and set the gate descriptor in `trap_init()`. Note that the DPL should be 3 to allow users to use this gate. The `syscall()` function in `kern/syscall.c` takes the syscall number as well as up to five arguments, which can be retrieved from `tf->tf_regs`. The corresponding registers are specified above, and also can be found in the inline assembly code in `lib/syscall.c`. Note that the `syscall` handler will return and continue to execute other things after it, so we need to put the "unexpected trap" part in the `else` branch. \
We could find out how the arguments are passed in by looking at `lib/syscall.c`. `sys_cputs()` use `a1, a2` as its two parameters, and `sys_env_destroy` uses the `a1` as its only parameter. Note that the second argument of `syscall()` in `lib/syscall.c` is `check`, so the five arguments start from the third one. Then we could just invoke different functions with correct arguments for different syscall number in `kern/syscall.c`. \
The whole procedure should be that `sys_*` functions in `lib/syscall.c` are used for user's system calls and invoke `int $0x30` in `syscall()` of `lib/syscall.c` with the inline assembly code. The inline assembly code has the syntax `asm volatile ("asm code": output: input: changed)`. `a, b, c, d, D, S` indicates corresponding registers and `i` is for immediates. \
To handle this interrupt, `kern/trap.c` dispatches the interrupt of `T_SYSCALL` and invoke `syscall()` of `kern/syscall.c`, which takes argument values from the current `struct Trapframe`'s registers and goes to certain `sys_*` functions in `kern/syscall.c` to handle the interrupt.

## User-mode startup
### Exercise 8
We could use `sys_getenvid()` to get the current environment id and use `ENVX` macro to find out the index at which it's located in the `envs`. We mapped `UENVS` earlier in Part A so that the user can also read the `envs` array. (What does the set in `lib/entry.S` do ?)

## Page faults and memory protection
Memory protection is to ensure bugs in one program cannot corrupt other programs or the operating system itself. The os keeps the hardware informed about which virtual addresses are not valid, and when a program tries to access an invalid address or without permission, the processor traps into the kernel. Fixable faults could be fixed and return, while unfixable fault will just stuck there. Automatically extended stack is a fixable fault example.\
System calls can let user programs pass pointers to the kernel. The kernel could dereference the pointer, which might cause a page fault. The kernel needs to remember these page faults are actually on behalf of users. Another problem is that the pointer might be pointing to something the user cannot read or write but the kernel has permission to do that. So the kernel needs to be careful not to be tricked to dereference these pointers.

### Exercise 9
Check the RPL (bit 1-0) of `tf_cs` and 0 means a page fault happens inside the kernel (?). \
`user_mem_check` checks whether a part of addresses is outside `ULIM` or has wrong permission. This could be checked by walking through corresponding page table entries by `pgdir_walk()`. We could use `user_mem_assert` to do checking (and destroy malicious environments (?)), for example in `sys_cputs()` checking the validness of the string. In `debuginfo_eip()` of `kern/kdebug.c` we could use `sizeof` to specify address length and do checking. \
In `lib/entry.S` we compare `USTACKTOP` and `%esp`. `USTACKTOP` is set as `tf_esp` in `env_alloc()` when every environment is allocated, and is used to set registers in `env_pop_tf()`, which is called in `env_run()` and leads to `lib/entry.S` (when we return from trap handlers we also call `env_run(curenv)` to continue the user environment). There will be only two dummy arguments (`argc/argv`) pushed into stack, but in `mon_backtrace()` we need to print five arguments after `eip`, which might access to unauthorized memory.